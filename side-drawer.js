/***
Copyright 2016 TJ Woon

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
***/

// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var SideDrawer, closeDrawer, drawerWidth, openDrawer, swipeToCloseHandler, swipeToOpenHandler;

  openDrawer = function() {
    var fullyOpen, me;
    me = this;
    fullyOpen = this.fullyOpen;
    if (fullyOpen == null) {
      fullyOpen = drawerWidth.call(this);
    }
    this.holder.show();
    this.drawer.css("transition", "transform " + this.options.speed + "s ease-out").css("transform", "translate3d(" + fullyOpen + "px,0px,0px)");
    this.holder.css("transition", "background " + this.options.speed + "s ease-out").css("background", "rgba(0,0,0," + this.options.opacity + ")");
    this.previousOverflow = this.parent.css("overflow");
    this.parent.css("overflow", "hidden");
    this.fingerId = void 0;
    return this.handleEvent = swipeToCloseHandler;
  };

  closeDrawer = function() {
    var me;
    me = this;
    this.drawer.css("transition", "transform " + this.options.speed + "s ease-out").css("transform", "translate3d(0px,0px,0px)");
    this.holder.css("transition", "background " + this.options.speed + "s ease-out").css("background", "rgba(0,0,0,0)");
    this.parent.css("overflow", this.previousOverflow);
    this.fingerId = void 0;
    setTimeout((function() {
      return me.holder.hide();
    }), 300);
    return this.handleEvent = swipeToOpenHandler;
  };

  drawerWidth = function() {
    var outerWidth;
    this.holder.css("visibility", "hidden").css("display", "block");
    outerWidth = this.drawer.outerWidth();
    this.holder.css("visibility", "visible").css("display", "none");
    return outerWidth;
  };

  swipeToOpenHandler = function(evt) {
    var darkness, delta, earliest, i, j, latest, left, len, len1, now, ref, ref1, results, results1, touch, velocity;
    switch (evt.type) {
      case "touchstart":
        left = this.holder[0].getBoundingClientRect().left;
        if (this.fingerId == null) {
          touch = evt.changedTouches[0];
          if (touch.clientX - left <= this.options.sensitivity) {
            this.fingerId = touch.identifier;
            this.startX = touch.clientX;
            this.offset = 0;
            this.offsetList = [];
            this.fullyOpen = drawerWidth.call(this);
            this.drawer.css("transition", "none");
            this.holder.css("transition", "none");
          }
          return evt.stopPropagation();
        }
        break;
      case "touchmove":
        if (this.fingerId == null) {
          return;
        }
        ref = evt.changedTouches;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          touch = ref[i];
          if (this.fingerId === touch.identifier) {
            delta = Math.round(touch.clientX - this.startX);
            this.offset = Math.max(0, Math.min(this.fullyOpen, delta));
            this.drawer.css("transform", "translate3d(" + this.offset + "px,0px,0px)");
            this.offsetList.push({
              offset: this.offset,
              time: (new Date).getTime()
            });
            while (this.offsetList.length >= 10) {
              this.offsetList.shift();
            }
            darkness = this.offset / this.fullyOpen * this.options.opacity;
            this.holder.css("background", "rgba(0,0,0," + (darkness.toFixed(3)) + ")");
            if (this.offset > 0) {
              this.holder.show();
            } else {
              this.holder.hide();
            }
            evt.stopPropagation();
            results.push(evt.preventDefault());
          } else {
            results.push(void 0);
          }
        }
        return results;
        break;
      case "touchend":
      case "touchcancel":
        if (this.fingerId == null) {
          return;
        }
        ref1 = evt.changedTouches;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          touch = ref1[j];
          if (this.fingerId === touch.identifier) {
            now = (new Date).getTime();
            while (this.offsetList.length && (now - this.offsetList[0].time > 300)) {
              this.offsetList.shift();
            }
            earliest = this.offsetList[0];
            latest = this.offsetList.slice(-1)[0];
            if (earliest === latest) {
              velocity = 0;
            } else {
              velocity = (this.offset - earliest.offset) / (now - earliest.time) * 1000;
            }
            if (velocity >= 0 && (velocity >= this.options.threshold || this.offset >= this.options.offset)) {
              openDrawer.call(this);
            } else {
              closeDrawer.call(this);
            }
            evt.stopPropagation();
            this.fingerId = void 0;
            this.startX = void 0;
            this.offset = void 0;
            this.offsetList = void 0;
            this.fullyOpen = void 0;
            this.previousOverflow = void 0;
            break;
          } else {
            results1.push(void 0);
          }
        }
        return results1;
    }
  };

  swipeToCloseHandler = function(evt) {
    var darkness, delta, earliest, i, j, latest, len, len1, now, ref, ref1, results, results1, right, touch, velocity;
    switch (evt.type) {
      case "touchstart":
        right = this.drawer[0].getBoundingClientRect().right;
        if (this.fingerId == null) {
          touch = evt.changedTouches[0];
          if (right - this.options.sensitivity <= touch.clientX) {
            this.fingerId = touch.identifier;
            this.startX = touch.clientX;
            this.fullyOpen = this.drawer.outerWidth();
            this.offset = this.fullyOpen;
            this.offsetList = [];
            this.drawer.css("transition", "none");
            this.holder.css("transition", "none");
          }
          return evt.stopPropagation();
        }
        break;
      case "touchmove":
        if (this.fingerId == null) {
          return;
        }
        ref = evt.changedTouches;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          touch = ref[i];
          if (this.fingerId === touch.identifier) {
            delta = Math.round(touch.clientX - this.startX);
            this.offset = Math.max(0, Math.min(this.fullyOpen, this.fullyOpen + delta));
            this.drawer.css("transform", "translate3d(" + this.offset + "px,0px,0px)");
            this.offsetList.push({
              offset: this.offset,
              time: (new Date).getTime()
            });
            while (this.offsetList.length >= 10) {
              this.offsetList.shift();
            }
            darkness = this.offset / this.fullyOpen * this.options.opacity;
            this.holder.css("background", "rgba(0,0,0," + (darkness.toFixed(3)) + ")");
            if (this.offset > 0) {
              this.holder.show();
            } else {
              this.holder.hide();
            }
            evt.stopPropagation();
            results.push(evt.preventDefault());
          } else {
            results.push(void 0);
          }
        }
        return results;
        break;
      case "touchend":
      case "touchcancel":
        if (this.fingerId == null) {
          return;
        }
        ref1 = evt.changedTouches;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          touch = ref1[j];
          if (this.fingerId === touch.identifier) {
            now = (new Date).getTime();
            while (this.offsetList.length && (now - this.offsetList[0].time > 300)) {
              this.offsetList.shift();
            }
            earliest = this.offsetList[0];
            latest = this.offsetList.slice(-1)[0];
            if (earliest === latest) {
              velocity = 0;
            } else {
              velocity = (this.offset - earliest.offset) / (now - earliest.time) * 1000;
            }
            if (velocity < 0 && (velocity <= -this.options.threshold || this.offset <= this.fullyOpen - this.options.offset)) {
              closeDrawer.call(this);
            } else {
              openDrawer.call(this);
            }
            evt.stopPropagation();
            this.fingerId = void 0;
            this.startX = void 0;
            this.offset = void 0;
            this.offsetList = void 0;
            this.fullyOpen = void 0;
            this.previousOverflow = void 0;
            break;
          } else {
            results1.push(void 0);
          }
        }
        return results1;
    }
  };

  SideDrawer = function(elt, conf) {
    var event, i, len, me, ref;
    if (conf == null) {
      conf = {};
    }
    me = this;
    this.options = $.extend({
      sensitivity: 60,
      threshold: 300,
      offset: 120,
      opacity: 0.6,
      speed: 0.2
    }, conf);
    this.holder = $(elt);
    this.drawer = this.holder.children().eq(0);
    this.parent = this.holder.parent();
    this.fingerId = void 0;
    this.startX = void 0;
    this.offset = void 0;
    this.offsetList = void 0;
    this.fullyOpen = void 0;
    this.previousOverflow = void 0;
    $(this.holder).Touch();
    $(this.holder).on("tap", function() {
      return closeDrawer.call(me);
    });
    $(this.drawer).on("tap", function(evt) {
      return evt.stopPropagation();
    });
    this.holder.hide();
    this.holder.css("position", "absolute");
    this.holder.css("top", "0px");
    this.holder.css("bottom", "0px");
    this.holder.css("left", "0px");
    this.holder.css("right", "0px");
    this.holder.css("z-index", "9000");
    this.drawer.css("position", "absolute");
    this.drawer.css("top", "0px");
    this.drawer.css("bottom", "0px");
    this.drawer.css("left", "0px");
    this.drawer.css("width", "calc(100% - 60px)");
    this.drawer.css("margin-left", "calc(-100% + 60px)");
    this.handleEvent = swipeToOpenHandler;
    ref = ["touchstart", "touchmove", "touchend", "touchcancel"];
    for (i = 0, len = ref.length; i < len; i++) {
      event = ref[i];
      this.parent[0].addEventListener(event, this, false);
    }
    return this;
  };

  SideDrawer.prototype.open = function() {
    return openDrawer.call(this);
  };

  SideDrawer.prototype.close = function() {
    return closeDrawer.call(this);
  };

  SideDrawer.version = "0.0.2";

  $.fn.SideDrawer = function(conf) {
    return this.each(function() {
      var d;
      d = $(this).data("SideDrawer");
      if (d == null) {
        d = new SideDrawer(this, conf);
        $(this).data("SideDrawer", d);
      }
      return d;
    });
  };

  $.SideDrawer = SideDrawer;

}).call(this);
